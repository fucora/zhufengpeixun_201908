<!DOCTYPE html>
<html>
<head>
	<title>插入排序</title>
</head>
<body>
<script type="text/javascript">
	/*
     * quick：实现快速排序
     *   @params
     *     ary [ARRAY] 需要排序的数组
     *   @return 
     *     [ARRAY] 排序后的新数组
     * by zhouxiaotian on 2019/07/26
     */
	function quick(ary){
		// 4.结束递归（当ARY中小于等于一项，则不用处理）
		if(ary.length<=1){
			return ary;
		}
		// 1.找到数组的中间项，在原有的数组中把它移除
		let middleIndex=Math.floor(ary.length/2);
		let middleValue=ary.splice(middleIndex,1)[0];
		// 2.准备左右两个数组，循环剩下数组中的每一项，比当前项小的放到左边数组中，反之放到右边数组中
		let aryLeft=[],
			aryRight=[];
		for(let i=0;i<ary.length;i++){
			let item=ary[i];
			item<middleValue?aryLeft.push(item):aryRight.push(item);
		}
		// 3.递归方式让左右两边的数组持续这样处理，一直到左右两边都排好序为止（最后让左边+中间+右边拼接成为最后的结果）
		return quick(aryLeft).concat(middleValue,quick(aryRight));  
	}
	let ary = [12,8,15,16,1,24];
	ary=quick(ary);
	console.log(ary);


	// 递归：函数执行的时候自己调用自己
	/*
	function fn(){
		fn(); //=>Uncaught RangeError: Maximum call stack size exceeded 这种死递归会导致栈溢出
	}
	fn();
	*/
	/*
	function fn(){
		setTimeout(fn,0);//=>这种看似像死递归的方法不会导致栈溢出错误
	}
	fn();
	*/

	// 获取1-10的和
	// let total=null;
	// for(let i=1;i<=10;i++){
	// 	total+=i;
	// }
	// console.log(total);

	/*
	function sum(n){
		if(n>10){
			return 0;
		}
		return n+sum(n+1);
		// return 1+sum(2)
		// return 1+2+sum(3)
		// ...
		// return 1+2+3+4+5+6+7+8+9+10+sum(11)
		// return 1+2+3+4+5+6+7+8+9+10+0
	}
	let total=sum(1);
	console.log(total);
	*/
</script>
</body>
</html>